\documentclass{DTAS07}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{polski}
\usepackage[cp1250]{inputenc}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath}
\usepackage{url}

\title{PRZESZUKIWANIE LOKALNE DLA PROBLEMU SAT\\
{\small Dokumentacja projektu z przedmiotu WMH}
}

\author{Micha³ Skrzêdziejewski, Micha³ Kozakiewicz}

\begin{document}
%\maketitle
\thispagestyle{empty}

\section{WSTÊP}
Problem spe³nialnoœci wyra¿eñ logicznych (ang. {\em Boolean satisfiability 
problem}), w skrócie zwany SAT, jest kluczowym problemem teorii obliczalnoœci
i logiki matematycznej.
Nieformalnie mo¿na go sformu³owaæ nastêpuj¹co: maj¹c dane wyra¿enie logiczne w 
postaci zbioru klauzul, czy
istnieje przypisanie zmiennych w tych klauzulach takie, ¿e wszystkie te klauzule
s¹ spe³nione?

Problem SAT jest pierwszym problemem co do którego udowodniono, ¿e jest 
NP-zupe³ny. By³ on dog³êbnie studiowany, st¹d te¿ na jego temat powsta³o wiele
ksi¹¿ek i opracowañ. Multum zagadnieñ praktycznych (projektowanie uk³adów
scalonych) oraz teoretycznych (kolorowanie grafów) mo¿na sprowadziæ do problemu
SAT.

W wypadku wielu trudnych problemów SAT przegl¹danie ca³ej przestrzeni rozwi¹zañ 
jest zwykle zbyt kosztowne obliczeniowo. Dlatego te¿ powsta³o wiele metod 
przybli¿onych, które nie sprawdzaj¹ ca³ej przestrzeni rozwi¹zañ. Jedn¹ z popularnych metod heurystycznych jest przeszukiwanie lokalne. W ramach projektu zostan¹ zaimplementowane dwa warianty przeszukiwania lokalnego dla problemu SAT.


\section{SFORMU£OWANIE PROBLEMU}
{\em Zmienn¹ zdaniow¹} $x_i$ nazywamy zmienn¹ przyjmuj¹c¹ wartoœci ze zbioru
$\{1,0\}$. Wartoœæ zmiennej zdaniowej mo¿na interpretowaæ jako prawdê ($1$) lub
fa³sz ($0$).

{\em Litera³em} $l$ jest zmienna $x_i$ lub jej negacja $\overline{x_i}$.

{\em Przypisaniem} $x$ jest wektor kolumnowy o rozmiarze $n$ zawieraj¹cy jako elementy wartoœci zmiennych $x_1 \dots x_n$.

{\em Klauzul¹} $c$ w postaci dysjunkcyjnej jest zbiór litera³ów po³¹czonych 
operatorem alternatywy, np. $(x_2 \vee x_3 \vee x_6)$. Przypisanie $x$ spe³nia klauzulê $c$, jeœli istnieje chocia¿ jeden litera³ $l$ w klauzuli $c$ taki, ¿e
jeœli $l$ jest pozytywny (postaci $x_i$) to $x_i = 1$, a jeœli $l$ jest negatywny (postaci $\overline{x_i}$) to $x_i = 0$.

{\em Wyra¿eniem logicznym} w postaci koniunkcyjnej normalnej (CNF - Conjunctive Normal Form) nazywamy zbiór 
klauzul w postaci dysjunkcyjnej po³¹czonych operatorem koniunkcji, np. $(x_1 \vee x_2 \vee x_3) \wedge
(x_2 \vee x_3 \vee x_5)$. W dalszym ci¹gu bêdziemy rozwa¿aæ tylko wyra¿enia w postaci CNF. 

Mo¿na dokonaæ kategoryzacji problemu SAT ze wzglêdu na maksymaln¹ liczbê litera³ów w klauzuli. Dla jednego litera³u (1-SAT) problem jest trywialny i da siê go rozwi¹zaæ w czasie liniowym. Dla dwóch litera³ów (2-SAT) mo¿na to zrobiæ w czasie wielomianowym. Problem $k$-SAT, gdzie $k > 2$ jest problemem
NP-zupe³nym. Najczêœciej rozwa¿a siê problem 3-SAT i on w³aœnie bêdzie przedmiotem badañ przeprowadzonych w ramach projektu.

\section{PRZESZUKIWANIE LOKALNE}
Heurystyki zak³adaj¹, i¿ nie potrzeba przeszukiwaæ ca³ej przestrzeni
rozwi¹zañ aby znaleŸæ rozwi¹zanie optymalne. W klasycznej metodzie przeszukiwania lokalnego, algorytm startuje z pewnego rozwi¹zania pocz¹tkowego (zwykle wybranego losowo) a nastêpnie eksploruje otoczenie bie¿¹cego punktu
w poszukiwaniu lepszego rozwi¹zania. W tym celu, dla danego problemu, musimy zdefiniowaæ zarówno funkcjê celu, która umo¿liwi nam ocenê rozwi¹zañ, jak i 
s¹siedztwo danego punktu w przestrzeni poszukiwañ. Doœæ czêstym zjawiskiem jest
utkniêcie w minimum lokalnym, zatem po wykryciu takiej sytuacji nale¿y ponownie 
uruchomiæ algorytm z nowym punktem pocz¹tkowym, zapamiêtuj¹c oczywiœcie najlepsze dotychczasowe rozwi¹zanie.

W przypadku problemu SAT otoczenie mo¿na zdefiniowaæ intuicyjnie - s¹ to rozwi¹zania ró¿ni¹ce siê przypisaniem jednej zmiennej. Gorzej jest z funkcj¹ celu: przypisanie $x$ albo spe³nia wyra¿enie logiczne, albo nie.
Mo¿na jednak jako minimalizowan¹ funkcjê przyj¹æ liczbê klauzul, które nie s¹ spe³nione. Niech $C(x)$ oznacza liczbê niespe³nionych klauzul dla przypisania $x$, $N(x)$ oznacza funkcjê s¹siedztwa a $select(x^i,N(x^i))$ wybiera nastêpne
przypisanie na podstawie bie¿¹cego przypisania i jego s¹siadów. Wtedy 
zgeneralizowany algorytm przeszukiwania lokalnego wygl¹da nastêpuj¹co:

\begin{algorithm}
\begin{algorithmic}
\STATE Wybierz $x^0$
\STATE $k\gets 0$
\WHILE {$C(x^k) > 0$}
\STATE $N\gets N(x^k)$
\STATE $x^{k+1}\gets select(x^k, N)$
\STATE $k\gets k+1$
\ENDWHILE
\end{algorithmic}
\end{algorithm}

Na pocz¹tku wybierane jest (zwykle w sposób losowy) pocz¹tkowe rozwi¹zanie $x^0$. Nastêpnie, dopóki wszystkie klauzule nie bêd¹ spe³nione, algorytm wybiera
z otoczenia punktu $x^0$ nastêpne przypisanie, zgodnie z pewn¹ ustalon¹ strategi¹. Zwykle wprowadza siê dodatkowe kryteria zatrzymania algorytmu, zwi¹zane z utkniêciem w minimum lokalnym lub przekroczeniem maksymalnej iloœci 
iteracji.

W podstawowej wersji przeszukiwania lokalnego mamy do czynienia z dwoma rodzajami funkcji wybieraj¹cej nastêpne przypisanie. W algorytmie zach³annym ({\em ang. greedy}) wybierane jest przypisanie powoduj¹ce najwiêksz¹ poprawê w stosunku do bie¿¹cego przypisania. W algorytmie wspinaczkowym (ang. {\em hill-climbing}) wybierane jest pierwsze napotkane przypisanie, które nie powoduje pogorszenia uzyskanego wyniku. Najczêœciej po natrafieniu na minimum lokalne algorytm jest
restartowany. Zauwa¿my jednak, ¿e w ten sposób tracona jest informacja o ju¿
przeszukanej czêœci przestrzeni.

Podstawowy wariant przeszukiwania lokalnego mo¿na usprawniæ poprzez wprowadzenie
ca³kowicie losowego ruchu w przestrzeni poszukiwañ. Prawdopodobieñstwo takiego
ruchu zale¿y od parametru który zwykle maleje wraz z kolejnymi iteracjami. Mo¿na 
równie¿ skorzystaæ z metody symulowanego wy¿arzania. 

Przegl¹d ró¿nych usprawnieñ podstawowego algorytmu przeszukiwania lokalnego 
w zastosowaniu do problemu SAT mo¿na znaleŸæ w \cite{Bohlin}. Znajdujê siê tam 
równie¿ krótki opis bardziej zaawansowanych algorytmów, takich jak GSAT, WalkSAT, HSAT, Novelty, DLM i SDF.

\section{ALGORYTM WalkSAT}
Pierwszym algorytmem zaimplementowanym w ramach projektu mia³ byæ algorytm GSAT (Greedy SAT).
Okaza³o siê jednak ¿e mo¿na go bardzo ³atwo zmodyfikowaæ w celu uzyskania algorytmu WalkSAT, co te¿ 
zosta³o uczynione.

Oznaczmy jako $gselect(x,S)$ funkcjê, która z punktów s¹siaduj¹cych z $x$ wybiera ten, 
który prowadzi do najwiêkszej poprawy, a jako $rselect(x,S)$ funkcjê, która z s¹siedztwa $x$ 
wybiera punkt osi¹galny poprzez modyfikacjê jednej zmiennej w niespe³nionych klauzulach. 
Jako punkty s¹siaduj¹ce z $x$ uznajemy te, 
które ró¿ni¹ siê wartoœci¹ jednej zmiennej. Wtedy algorytm WalkSAT przedstawia siê nastêpuj¹co:

\begin{algorithm}
\begin{algorithmic}
\STATE $r\gets 0$
\WHILE {$r < MT$}
	\STATE wybierz losowo $x^0$
	\STATE $k\gets 0$
	\WHILE {$k < MF$}
		\IF {$C(x^k) = 0$}
			\RETURN{$x^k$}
		\ENDIF
		\STATE $N\gets N(x^k)$
		
        \STATE wybierz losowo $r$
        \IF {$r < \theta$}
            \STATE $x^{k + 1}\gets rselect(x^k,N)$
        \ELSE
            \STATE $x^{k + 1}\gets gselect(x^k,N)$
        \ENDIF
		\STATE $k\gets k +1$
	\ENDWHILE
\ENDWHILE
\end{algorithmic}
\end{algorithm}

$MT$ oznacza maksymaln¹ iloœæ prób a $MF$ maksymaln¹ iloœæ iteracji w jednej próbie.

Algorytm rozpoczyna przeszukiwanie od wylosowania pocz¹tkowego przypisania, a 
nastêpnie w ka¿dym kroku dokonuje jednego z dwóch mo¿liwych wyborów:

\begin{itemize}
    \item wykonuje krok zach³anny GSAT: wybiera przypisanie poprzez zmianê wartoœci pojedynczej zmiennej,
        które prowadzi do najwiêkszej poprawy jeœli chodzi o iloœæ spe³nionych klauzul
    \item zmienia wartoœæ zmiennej, losowo wybranej spoœród klauzul, które nie s¹ spe³nione.
\end{itemize}

Prawdopodobieñstwo losowego ruchu $\theta$ nale¿y ustawiæ na oko³o $0.2$. Okazuje siê ¿e ta stosunkowo 
nieskomplikowana modyfikacja powoduje znacz¹c¹ poprawê algorytmu. W naszej implementacji dodatkowo 
algorytm w kroku zach³annym wybiera losowo zmienn¹ jeœli wiele potencjalnych wyborów powoduje tê sam¹ poprawê.

\section{ALGORYTM DLM}
Drugim algorytmem zaimplementowanym w ramach projektu jest algorytm DLM (ang.
{\em Discrete Lagrange Multiplier} \cite{Shang}. 
Metody Lagrange'a s¹ klasycznymi metodami rozwi¹zywania 
ci¹g³ych problemów optymalizacyjnych z ograniczeniami. Przyk³adowo, mno¿niki Lagrange'a mo¿na zastosowaæ do rozwi¹zania 
nastêpuj¹cego problemu optymalizacyjnego: 
\begin{equation}
\begin{split}
	\min f(x)\\
 	g(x) = 0
\end{split}
\end{equation}
gdzie $f(x)$ jest funkcj¹ celu a $g(x)$ funkcj¹ ograniczeñ. Przekszta³cenie
do problemu optymalizacji bez ograniczeñ nastêpuje poprzez wprowadzenie
funkcji Lagrange'a zdefiniowanej nastêpuj¹co:
\begin{equation}
	L(x, \lambda) = f(x) + \sum_{i=1}^{n}\lambda_i g_i(x)
\end{equation} 
gdzie $\lambda = (\lambda_1, \dots, \lambda_n)$ jest wektorem mno¿ników 
Lagrange'a. Przyk³adowa metoda pierwszego rzêdu ``schodzi w dó³'' w przestrzeni 
zmiennej $x$ i ``wspina siê'' w przestrzeni mno¿ników Lagrange'a zgodnie z równaniami:

\begin{equation}
	\begin{split}
	\frac{dx}{dt} = -\nabla_x L_c(x, \lambda)\\
	\frac{d\lambda}{dt} = \nabla_\lambda L_c(x, \lambda)
	\end{split}
\end{equation}
Przejœcie do dziedziny dyskretnej nie nastrêcza trudnoœci. Wyczerpuj¹cy
opis metody mo¿na znaleŸæ w literaturze.

W przypadku SAT bêdziemy rozwi¹zywaæ nastêpuj¹cy problem optymalizacyjny:

\begin{equation}
	\begin{split}
	\min H(x) \\
	C_i(x) = 0 \quad \forall i \in \{1,2,\dots,n\}
	\end{split}
\end{equation}

Gdzie funkcj¹ celu jest $H(x)$ a ograniczeniem warunek mówi¹cy o tym, i¿ 
liczba niespe³nionych klauzul ma byæ równa zero. Algorytm DLM szuka
punktu siod³owego funkcji Lagrange'a okreœlonej jako:

\begin{equation}
	L(x,\lambda) = H(x) +\lambda^T U(x)
\end{equation}

Funkcja celu $H(x)$ jest wprowadzona sztucznie i musi byæ tak dobrana, 
aby punkty siod³owe znajdowane przez algorytm DLM by³y rozwi¹zaniami problemu SAT. 
Przyk³adowo, mo¿na funkcjê $H(x)$ okreœliæ w nastêpuj¹cy sposób:

\begin{equation}
	\begin{split}
		H(x) = 
		\begin{cases}
			\sum_{i=1}^n l_i C_i(x), \\
			\sum_{i=1}^n (l_{max} + 1 - l_i) C_i(x), \\
			\sum_{i=1}^n w_i C_i(x),
		\end{cases}
	\end{split}
\end{equation}
gdzie $l_i$ jest liczb¹ zmiennych w klauzuli $C_i$, $l_{max} = \max_{i=1}^n l_i$, a $w_i$ jest pewn¹ sta³¹ dodatni¹ (wag¹). Pierwsza funkcja nadaje wiêksz¹ wagê d³u¿szym klauzulom, druga dzia³a w odwrotny sposób. Trzecia u¿ywa arbitralnych wag. Decyduj¹c siê na trzeci¹ mo¿liwoœæ, funkcja Lagrange'a bêdzie
wygl¹da³a nastêpuj¹co:
\begin{equation}
	L(x, \lambda) = N(x) + \lambda^T C(x) = \sum_{i=1}^n(w_i +\lambda_i) C_i(x)
\end{equation}

Zdefiniujmy operator gradientu dyskretnego $\Delta_x L(x, \lambda)$ dla przypisania $x$ tak, ¿e wskazuje on na stan $x^\prime$ w otoczeniu punktu $x$ o 
odleg³oœci Hamminga równej 1, daj¹cy najwiêksz¹ poprawê funkcji $L(x,\lambda)$.
Jeœli ¿aden z rozwa¿anych stanów w otoczeniu punktu $x$ nie daje poprawy, to 
$\Delta_x L(x,\lambda) = 0$. Mo¿emy teraz przedstawiæ ogólny schemat dzia³ania algorytmu DLM:
\begin{algorithm}
\begin{algorithmic}
	\STATE wybierz pocz¹tkowe $x_0$
	\STATE wybierz pocz¹tkowe $\lambda$
	\WHILE{$N(x) > 0 $}
		\STATE $x\gets x \oplus \Delta_x L(x, \lambda)$
		\IF{warunek aktualizacji $\lambda$ jest spe³niony}
			\STATE $\lambda\gets \lambda +c \times C(x)$
		\ENDIF
	\ENDWHILE
\end{algorithmic}
\end{algorithm}

W naszej implementacji istnieje dodatkowo parametr $gamma$ wyznaczaj¹cy liczbê niespe³nionych klauzul,
powy¿ej której nastêpuje prze³¹czenie pomiêdzy trybem

\section{IMPLEMENTACJA}
\subsection{Œrodowisko}
Algorytmy zosta³y zaimplementowane w jêzyku Java. Do kompilacji i uruchomienia wymagany jest
pakiet \verb|JDK 5| (zalecamy \verb|JDK 6|). Klasy i metody w kodzie Ÿród³owym s¹ opisane
a dokumentacja mo¿e byæ wygenerowana z u¿yciem polecenia \verb|javadoc|. Poni¿ej znajduje siê
krótki opis najwa¿niejszych klas:

\begin{itemize}
    \item \verb|Clause|: klauzula zawieraj¹ca pewn¹ liczbê zmiennych
    \item \verb|BooleanFormula|: formu³a logiczna zawieraj¹ca pewn¹ liczbê klauzul
    \item \verb|Assignment|: wektor przypisania
    \item \verb|WalkSatSolver|: klasa implementuj¹ca algorytm WalkSAT
    \item \verb|DLMA1|: klasa implementuj¹ca algorytm DLM w wersji pierwszej
    \item \verb|SatSolver|: w tej klasie znajduje siê metoda \verb|main()| aplikacji
\end{itemize}

Dok³adniejszy opis klas i metod znajduje siê w kodzie Ÿród³owym (jako \verb|javadoc|).

\subsection{Katalog projektu}
W katalogu projektu znajduj¹ siê nastêpuj¹ce podkatalogi:
\begin{itemize}
    \item \verb|docs| - dokumentacja projektu,
    \item \verb|lib| - wymagane biblioteki w postaci plików jar,
    \item \verb|out| - miejsce na skompilowane klasy,
    \item \verb|problems| - przyk³adowe pliki zadañ w postaci DIMACS CNF,
    \item \verb|resourcescp| - w katalogu tym znajduje siê plik konfiguracyjny logowania,
    \item \verb|src| - kod Ÿród³owy,
    \item \verb|tasks| - pliki konfiguracyjne problemów.
\end{itemize}


\subsection{Format pliku zadania}
Pocz¹tkowe za³o¿yliœmy, ¿e formu³y bêd¹ wprowadzane w postaci symbolicznej a nastêpnie 
parsowane i dalej przetwarzane do wygodniejszej postaci. Okaza³o siê jednak, ¿e
w standardowych zadaniach liczba zmiennych wynosz¹ca 2000 lub liczba klauzul wynosz¹ca 20000
nie jest niczym niespotykanym. Z tego wzglêdu stosowanie zapisu symbolicznego jest niepraktyczne.

Formatem który wykorzystaliœmy jest DIMACS. Jest to prosty format pliku zadania najchêtniej 
wykorzystywany podczas zawodów algorytmów rozwi¹zywania problemu SAT. W sk³ad pliku DIMACS 
wchodz¹ kolejno:

\begin{itemize}
    \item Linie komentarzy (opcjonalne, mo¿e byæ ich dowolna iloœæ), gdzie jedna linia ma format
    \verb|c jakis komentarz|
    \item Linia zadania w formacie \verb|p cnf liczba_zmiennych liczba_klauzul|, np. \\
        \verb|p cnf 2653 19598|
    \item Linie klauzul w postaci \verb|zmienna1 zmienna2 zmienna3 (...) 0| gdzie ka¿da zmienna 
    mo¿e byæ dodatnia lub ujemna w zale¿noœci od tego czy jest w danej klauzuli zanegowana, czy nie. 
    Ka¿da klauzula jest zakoñczona liczb¹ 0 - nie jest wymagane, ¿eby klauzule by³y w osobnych liniach
    (jednak taki styl jest najczêœciej stosowany).
\end{itemize}

Dok³adny opis formatu mo¿na znaleŸæ pod adresem \url{http://www.cs.ubc.ca/~babic/doc/dimacs_cnf.pdf}.
Przyk³adowe pliki z zadaniami w tym formacie mo¿na znaleŸæ w katalogu \verb|problems| projektu.

\subsection{Kompilacja projektu}
Przed kompilacj¹ nale¿y upewniæ siê ¿e polecenie \verb|javac| jest
dostêpne w œcie¿ce wykonania (katalog bin z JDK powinien byæ ustawiony w zmiennej \verb|PATH| dla systemu
Windows lub \verb|$PATH| dla systemu Linux. Po rozpakowaniu archiwum nale¿y udaæ siê 
do katalogu projektu i wydaæ polecenie

\begin{itemize}
    \item \verb|build.bat| dla systemu Windows, lub, 
    \item \verb|./build.sh| dla systemu Linux (ew. poprzedziæ komend¹ \verb|chmod +x build.sh|).
\end{itemize}

Ze wzglêdu na prostotê zrezygnowaliœmy z u¿ycia narzêdzi wspomagaj¹cych kompilacjê typu Ant.

\subsection{Uruchomienie projektu}
Przed uruchomieniem projektu nale¿y upewniæ siê, ¿e polecenie \verb|java| jest dostêpne w
œcie¿ce wykonania. W celu uruchomienia aplikacji nale¿y udaæ siê do katalogu projektu i 
nastêpnie wydaæ polecenie

\begin{itemize}
    \item \verb|solver.bat plik_zadania plik_konfiguracyjny_zadania| dla systemu Windows, lub, 
    \item \verb|./solver.sh plik_zadania plik_konfiguracyjny_zadania| dla systemu Linux 
        (ew. poprzedziæ komend¹ \verb|chmod +x solver.sh|).
\end{itemize}

Przyk³adowe wywo³ania znajduj¹ siê w sekcji omawiaj¹cej testowanie algorytmu.

\subsection{Plik konfiguracyjny zadania}
Plik konfiguracyjny zadania umo¿liwia ustawienie:

\begin{itemize}
    \item maksymalnej liczby iteracji,
    \item limitu czasowego algorytmu, oraz
    \item parametrów algorytmów WalkSAT i DLM.
\end{itemize}

Dok³adny opis poszczególnych parametrów znajduje siê w przyk³adowych plikach.

\subsection{Plik konfiguracyjny logowania}
Plik konfiguracyjny biblioteki \verb|log4j| znajduje siê w katalogu \verb|resourcescp|. 
Poprzez zmianê wpisu \verb|INFO| na \verb|DEBUG| mo¿na w³¹czyæ wyœwietlanie dok³adnego przebiegu algorytmu.

\subsection{Przebieg dzia³ania programu}
Przebieg dzia³ania programu prezentuje siê nastêpuj¹co:

\begin{enumerate}
    \item Wczytanie pliku zadania
    \item Wczytanie konfiguracji
    \item Uruchomienie algorytmu WalkSAT w pêtli ,,du¿ych'' iteracji 
    \item Uruchomienie algorytmu DLM w pêtli ,,du¿ych'' iteracji
    \item Wyœwietlenie podsumowania
\end{enumerate}

Podczas ,,du¿ych'' iteracji (czyli kolejnych uruchomieñ algorytmu z nowym przypisaniem) mo¿e siê
zdarzyæ, ¿e algorytm znajdzie rozwi¹zanie. Wtedy pêtla ,,du¿ych'' iteracji jest przerywana.
Zrezygnowaliœmy tak¿e z wyœwietlania rozwi¹zania w postaci zer i jedynek, gdy¿ by³oby to 
nieporêczne przy liczbie zmiennych wynosz¹cej nawet tysi¹c.


\section{TESTOWANIE}
Ocena jakoœci konkretnego algorytmu odby³a siê bêdzie na podstawie 
analizy jego przebiegu dla pewnej liczby trudnych problemów 3-SAT. 
Istnieje mo¿liwoœæ losowego wygenerowania wyra¿eñ logicznych, jednak nale¿y bardzo uwa¿aæ przy doborze
parametrów rozk³adu. W przypadku Ÿle dobranych parametrów, wygenerowane wyra¿enia mog¹ byæ 
trywialne do rozwi¹zania i spe³nione przez losowo wygenerowane przypisanie. 
Aby unikn¹æ tych trudnoœci, do oceny wykorzystane zosta³y gotowe pliki trudnych problemów. 
Mo¿na je znaleŸæ np. na stronie \url{http://www.satlive.org/} w dziale ,,benchmarks''. 

Przy ocenie bêdzie brana by³a pod uwagê szeroko pojêta wydajnoœæ algorytmów.
Dla prostszych problemów mo¿na przyj¹æ jako kryterium jakoœci czas dzia³ania 
algorytmu w którym zadanie zostanie rozwi¹zane. Dla trudniejszych problemów, 
które mog¹ pozostaæ nierozwi¹zane, badano iloœæ spe³nionych 
klauzul po up³ywie ustalonego czasu lub pewnej iloœci iteracji. 

Aby ocena porównawcza algorytmów by³a sprawiedliwa, w kolejnych uruchomieniach
oba algorytmy startuj¹ z tego samego punktu pocz¹tkowego. Eliminuje to mo¿liwoœæ 
wylosowania przez jeden z algorytmów punktu który jest bli¿ej rozwi¹zania, tym samym
daj¹c mu przewagê.

Pierwszy, najprostszy test obejmowa³ formu³ê o 218 klauzulach i 
50 zmiennych. Zauwa¿my ¿e nawet w tak prostym przypadku przeszukiwanie ca³ej
przestrzeni musia³oby pokryæ $2^50$ rozwi¹zañ.
Test uruchamiany jest nastêpuj¹co:

\begin{verbatim}
    solver.bat problems\pr2.cnf tasks\task0.properties
\end{verbatim}

Przypadek ten nie pozwala na dobre porównanie algorytmów. 
Oba algorytmy b³yskawicznie dochodz¹ do rozwi¹zania.
Przyk³adowe 6 czasów znalezienia rozwi¹zania dla obu algorytmów (w milisekundach):

\vspace{1em}

\begin{tabular}{|l|l|}
\hline
WalkSAT & DLM \\
\hline
44 & 62\\ \hline
218 & 39\\ \hline
52 & 26\\ \hline
17 & 45\\ \hline
32 & 116\\ \hline
38 & 198\\ \hline
\end{tabular}

\vspace{1em}

Widaæ wyraŸnie jak du¿y jest rozrzut wartoœci. W tym teœcie nie ma wyraŸnego zwyciêzcy; 
dla tych samych punktów startowych algorytmy zachowuj¹ siê zgo³a odmiennie. Prawdopodobnie
zbiór testowy jest zbyt trywialny aby móc na nim testowaæ w³aœciwoœci omawianych algorytmów.

Drugi test zosta³ przeprowadzony na formule 
sk³adaj¹cej siê z 1065 klauzul i 250 zmiennych. 
Test uruchamiany jest nastêpuj¹co:

\begin{verbatim}
    solver.bat problems\pr7.cnf tasks\task1.properties
\end{verbatim}

W tym teœcie algorytmy mog³y startowaæ ponownie z 10 punktów pocz¹tkowych. 
Podczas kolejnych restartów algorytmy ,,utyka³y'' w miejscu, gdzie spe³nione 
by³o 1064 spoœród wymaganych 1065 klauzul. Dopiero 5 restart w przypadku 
DLM a 8 w przypadku WalkSAT pozwoli³ na znalezienie rozwi¹zania. 
Jednak œrednio mo¿na powiedzieæ, ¿e oba algorytmy spisywa³y siê podobnie.

Trzeci test zosta³ przeprowadzony na przyk³adzie 
o 4320 klauzulach i 917 zmiennych. Limit czasu wynosi³ ok. 2 godziny, 
liczba ponownych uruchomieñ - 5.
Test uruchamiany jest nastêpuj¹co:

\begin{verbatim}
    solver.bat problems\pr3.cnf tasks\task2.properties
\end{verbatim}

W tej próbie oba algorytmy mia³y sporo czasu ¿eby pokazaæ swoje dobre strony.
Z tej próby zwyciêsko wyszed³ DLM, któremu uda³o siê znaleŸæ rozwi¹zanie po
ok. 10 minutach. WalkSAT przekroczy³ dopuszczalny czas, a najlepsze rozwi¹zanie
które uda³o mu siê znaleŸæ spe³nia³o 4318 klauzul.

Ostatnim i najtrudniejszym problemem do rozwi¹zania by³a 
formu³a sk³adaj¹ca siê z 11973 klauzul (1858 zmiennych). 
Test uruchamiany jest nastêpuj¹co:

\begin{verbatim}
    solver.bat problems\pr4.cnf tasks\task3.properties
\end{verbatim}


Limit czasowy dla pojedynczego algorytmu jest ustawiony na ok. 2 godziny,
liczba ,,du¿ych iteracji'' (ponownych uruchomieñ) to 5. Okaza³o siê ¿e to zadanie przeros³o mo¿liwoœci obu algorytmów.
¯aden z nich nie zdo³a³ dojœæ do rozwi¹zania w wymaganym czasie. Algorytm WalkSAT
doszed³ do rozwi¹zania w którym 11955 klauzul by³o spe³nionych, natomiast
w przypadku DLM by³o to 11940 klauzul. 

\section{WNIOSKI KOÑCOWE}
Zadaniem projektowym by³o zaimplementowanie i porównanie dwóch algorytmów przeszukiwania lokalnego.
Oba algorytmy nie maj¹ problemu z formu³ami ze stosunkowo ma³¹ liczb¹ klauzul.
Algorytm WalkSAT radzi sobie bardzo dobrze zwa¿ywszy na jego prostotê. Na uwagê zas³uguje 
jego szybkoœæ dzia³ania i ³atwoœæ implementacji. Poprzez dodanie do algorytmu GSAT losowego ruchu
uzyskujemy znaczn¹ poprawê dzia³ania. 

Algorytm DLM cechuje siê du¿o d³u¿szym czasem trwania pojedynczej iteracji. 
Dla prostych problemów cechuje siê on podobnym czasem dzia³ania co algorytm WalkSAT. 
Jednak dla trudnego problemu z liczb¹ klauzul wynosz¹c¹ 4320 i liczb¹ zmiennych wynosz¹c¹ 
917 potrafi on, w przeciwieñstwie do WalkSAT znaleŸæ dok³adne rozwi¹zanie.
Poprzez wprowadzenie kolejnych modyfikacji opisanych przez autorów algorytmu mo¿na by
osi¹gn¹æ poprawê wydajnoœci \cite{ShangFirst}.

Warto podkreœliæ ¿e przyk³adowe problemy wykorzystane w testach nie powsta³y na drodze
,,sztucznej generacji'' a ich Ÿród³em s¹ rzeczywiste zagadnienia takie jak wykrywanie 
b³êdów przy produkcji procesorów. Problemy typu ,,benchmark'' stanowi¹ nie lada wyzwanie
dla projektantów algorytmów rozwi¹zuj¹cych problem SAT, która to dziedzina wci¹¿ aktywnie siê 
rozwija, czego potwierdzeniem s¹ corocznie organizowane zawody i coraz lepsze algorytmy.

\begin{thebibliography}{99}
\bibitem{Bohlin} M.~Bohlin, \textit{Local Search Techniques for SAT}
\bibitem{Selman} B.~Selman, H.~A.~Kautz, B.~Cohen, \textit{Local Search
Strategies for Satisfiability Testing}
\bibitem{ShangFirst} Y.~Shang, B.~W.~Wah, \textit{A Discrete Lagrangian-Based Global-Search method for Satisfiability Problems}
\bibitem{Shang} Y.~Shang, B.~W.~Wah, \textit{Improving the Performance of Discrete Lagrange-Multiplier Search for Solving Hard SAT Problems}
\end{thebibliography}

\end{document}
